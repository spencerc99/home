---
import type { CollectionEntry } from "astro:content";
import FormattedDate from "../components/FormattedDate.astro";
import { marked } from "marked";
import { CreationDetailImages } from "../components/CreationDetailImages";
import { RelatedCreations } from "../components/RelatedCreations";
import "./CreationDetail.scss";
import BaseLayout from "./BaseLayout.astro";
import { ImageOrVideo } from "../components/ImageOrVideo";
import { stringToColor } from "../utils";
import { maybeTransformImgixUrl } from "../utils/images";

type Props = CollectionEntry<"collection">["data"] & {
  relatedCreations?: Array<
    CollectionEntry<"creation">["data"] & { id: string }
  >;
};

const {
  title,
  descriptionMd,
  date,
  subtext,
  heroImage,
  media,
  link,
  shouldIframe,
  movieUrl,
  movieEmbed,
  materials,
  imageDescriptions,
  mediaMetadata,
  relatedCreations = [],
  descriptionFooter,
} = Astro.props;
const descriptionParsed = descriptionMd
  ? await marked.parse(
      // Convert any single \n that isn't preceded by two spaces into \n\n
      descriptionMd.replace(/(?<!  )\n&nbsp;/g, "\n\n"),
      {
        breaks: true,
        gfm: true,
      }
    )
  : "";

const descriptionFooterParsed = descriptionFooter
  ? await marked.parse(descriptionFooter, {
      breaks: true,
      gfm: true,
    })
  : "";

const transformedMovieUrl = movieUrl
  ? maybeTransformImgixUrl(movieUrl, {
      auto: "format,compress",
      fit: "max",
      w: "2000",
      h: "2000",
    })
  : movieUrl;
const transformedHeroImage = heroImage
  ? maybeTransformImgixUrl(heroImage, {
      auto: "format,compress",
      fit: "max",
      w: "2000",
      h: "2000",
    })
  : heroImage;
const mediaTransformed = media.map((item) => {
  return maybeTransformImgixUrl(item, {
    auto: "format,compress",
    fit: "max",
    w: "2000",
    h: "2000",
  });
});

const style = {
  "--aura-color": stringToColor(title),
  "--aura-color-transparent": stringToColor(title, {
    alpha: 0.3,
  }),
};

// Parse description into paragraphs for mobile interspersing
const descriptionParagraphs = descriptionParsed
  ? descriptionParsed.split("\n").filter((p) => p.trim())
  : [];

console.log(descriptionParagraphs);

// Organize media - all media including movieUrl if present
const allMediaSources = movieUrl ? [transformedMovieUrl] : [];
allMediaSources.push(...mediaTransformed);

const allDescriptions = movieUrl ? [""] : [];
allDescriptions.push(...(imageDescriptions || []));

const allMetadata = movieUrl ? [{ type: "video" }] : [];
allMetadata.push(...(mediaMetadata || []));

// Helper function to extract domain from URL
function getDomainFromUrl(url: string): string {
  try {
    const urlObj = new URL(url);
    return urlObj.hostname.replace("www.", "");
  } catch {
    return url;
  }
}

const linkDomain = link ? getDomainFromUrl(link) : "";

// // Function to create mobile interspersed content
// function createMobileContent(
//   paragraphs: string[],
//   mediaSources: string[],
//   descriptions: string[],
//   metadata: any[]
// ) {
//   const content: Array<{
//     type: "text" | "image" | "video";
//     content?: string;
//     src?: string;
//     description?: string;
//     metadata?: any;
//     index?: number;
//   }> = [];
//   let mediaIndex = 0;

//   // Add first media item
//   if (mediaSources[0]) {
//     content.push({
//       type: movieUrl ? "video" : "image",
//       src: mediaSources[0],
//       description: descriptions[0],
//       metadata: metadata[0],
//       index: 0,
//     });
//     mediaIndex = 1;
//   }

//   // Intersperse paragraphs with media every 2 paragraphs
//   paragraphs.forEach((paragraph, i) => {
//     // Only add non-empty paragraphs
//     if (paragraph.trim()) {
//       content.push({ type: "text", content: paragraph });

//       if ((i + 1) % 2 === 0 && mediaIndex < mediaSources.length) {
//         content.push({
//           type: "image",
//           src: mediaSources[mediaIndex],
//           description: descriptions[mediaIndex],
//           metadata: metadata[mediaIndex],
//           index: mediaIndex,
//         });
//         mediaIndex++;
//       }
//     }
//   });

//   return content;
// }

// const mobileContent = createMobileContent(
//   descriptionParagraphs,
//   allMediaSources,
//   allDescriptions,
//   allMetadata
// );
---

<BaseLayout title={title} description={subtext} image={heroImage}>
  <!-- <script is:inline>
    document.addEventListener("DOMContentLoaded", () => {
      const items = document.querySelectorAll(".media-item, .media-block");

      items.forEach((item) => {
        const media = item.querySelector("img, video");
        const caption = item.querySelector(".descriptionText");

        if (media && caption) {
          // Function to set the width and display the caption
          const setCaptionAndItemWidth = () => {
            const newWidth = media.clientWidth;
            if (newWidth) {
              // Set the caption's width
              caption.style.width = newWidth + "px";
              caption.style.display = "block";

              // Set the flex-basis of the parent item to the image's width
              // This allows the item to be a fluid flex container
              item.style.flexBasis = newWidth + "px";
            }
          };

          // Immediately apply the width in case the media is already loaded
          setCaptionAndItemWidth();

          // Add a listener for when the media loads
          media.addEventListener("load", setCaptionAndItemWidth, {
            once: true,
          });

          // Add a ResizeObserver to handle changes to the media's size after the initial load
          const ro = new ResizeObserver((entries) => {
            for (let entry of entries) {
              const newWidth = Math.round(entry.contentRect.width);
              const currentWidth = parseInt(item.style.flexBasis, 10);

              // Only update if the width has changed
              if (newWidth && newWidth !== currentWidth) {
                item.style.flexBasis = newWidth + "px";
                caption.style.width = newWidth + "px";
              }
            }
          });

          ro.observe(media);
        }
      });
    });
  </script> -->
  <main class="creationDetail editorial">
    <article>
      <!-- Desktop Editorial Layout -->
      <div class="desktop-layout">
        <!-- Title and Metadata Row -->
        <div>
          <div class="title-metadata-row">
            <h1 class="title-sentence">
              <>
                <b class="creation-title">{title}</b>
                {subtext ? ` is ${subtext}` : ""}
              </>
            </h1>
            <!-- Metadata Sidebar -->
            <div class="metadata-sidebar">
              {
                date && (
                  <div class="date">
                    <FormattedDate date={date} />
                  </div>
                )
              }
              <!-- TODO: add link section for other links-->
              {
                link && (
                  <div class="link">
                    <a href={link}>visit {linkDomain}</a>
                  </div>
                )
              }
              {materials && <div class="materials">Materials: {materials}</div>}
            </div>
          </div>
          <!-- Hero Row -->
          <div class="hero-row" style={style}>
            {
              shouldIframe ? (
                <div class="iframeWrapper">
                  <iframe src={link} />
                  <div>
                    window into <a href={link}>{link}</a>
                  </div>
                </div>
              ) : movieEmbed ? (
                <iframe class="movieEmbed" src={movieEmbed} />
              ) : (
                allMediaSources.slice(0, 4).map((src, i) => (
                  <div class="media-item" key={i}>
                    {movieUrl && i === 0 ? (
                      <video controls autoplay loop>
                        <source src={src} type="video/webm" />
                      </video>
                    ) : (
                      <ImageOrVideo
                        client:only="react"
                        className="medium-masonry"
                        src={src}
                        type={allMetadata[i]}
                      />
                    )}
                    {allDescriptions[i] && (
                      <p class="descriptionText">{allDescriptions[i]}</p>
                    )}
                  </div>
                ))
              )
            }
          </div>
          <!-- Two-Column Description -->
          <div class="flex gap-">
            <div class="description-columns">
              {descriptionParsed && <div set:html={descriptionParsed} />}
            </div>
            <div class="meta small" set:html={descriptionFooterParsed} />
          </div>
        </div>

        <!-- Flow Images -->
        <div class="flow-images">
          <CreationDetailImages
            images={allMediaSources}
            descriptions={allDescriptions}
            client:only="react"
            metadata={allMetadata}
          />
        </div>

        <!-- Related Creations -->
        {
          relatedCreations.length > 0 && (
            <div class="related-creations">
              <RelatedCreations
                client:only="react"
                creations={relatedCreations}
              />
            </div>
          )
        }
      </div>
    </article>
  </main>
  <script src="https://player.vimeo.com/api/player.js"></script>
</BaseLayout>
